diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py
index 2d4f67bba..f5bcc946b 100644
--- a/sphinx/util/typing.py
+++ b/sphinx/util/typing.py
@@ -34,6 +34,51 @@ if False:
     from typing import Type  # NOQA # for python3.5.1
 
 
+# Helper functions for resolving incorrect __module__ attributes
+import builtins
+import sys
+
+_MODULE_CACHE = {}  # type: Dict[type, str]
+
+def _is_real_builtin(cls: type) -> bool:
+    """Check if cls is a real built-in type (defined in builtins module)."""
+    return hasattr(builtins, cls.__name__) and getattr(builtins, cls.__name__) is cls
+
+def _get_real_module(cls: type) -> str:
+    """Get the correct public module name for a class.
+    
+    This handles classes with incorrect __module__ attribute (e.g., struct.Struct
+    has __module__ == 'builtins' in Python <3.9, or '_struct' in Python >=3.9).
+    """
+    module = cls.__module__
+    if module in ('builtins', '__builtin__'):
+        if _is_real_builtin(cls):
+            return module
+        # Not a real built-in, try to find the real module
+        cached = _MODULE_CACHE.get(cls)
+        if cached is not None:
+            return cached
+        # Search through loaded modules for a module that exports this class
+        for modname, mod in sys.modules.items():
+            if modname == 'builtins' or modname == '__builtin__':
+                continue
+            try:
+                if getattr(mod, cls.__name__, None) is cls:
+                    _MODULE_CACHE[cls] = modname
+                    return modname
+            except Exception:
+                # Ignore any errors when accessing module attributes
+                pass
+        # Fallback: keep original module
+        _MODULE_CACHE[cls] = module
+        return module
+    elif module == '_struct':
+        # map internal _struct module to public struct module
+        return 'struct'
+    else:
+        return module
+
+
 # An entry of Directive.option_spec
 DirectiveOption = Callable[[str], Any]
 
@@ -96,7 +141,8 @@ def restify(cls: Optional["Type"]) -> str:
         return '...'
     elif inspect.isNewType(cls):
         return ':class:`%s`' % cls.__name__
-    elif cls.__module__ in ('__builtin__', 'builtins'):
+    real_module = _get_real_module(cls)
+    if real_module in ('__builtin__', 'builtins') and _is_real_builtin(cls):
         return ':class:`%s`' % cls.__name__
     else:
         if sys.version_info >= (3, 7):  # py37+
@@ -108,9 +154,10 @@ def restify(cls: Optional["Type"]) -> str:
 def _restify_py37(cls: Optional["Type"]) -> str:
     """Convert python class to a reST reference."""
     from sphinx.util import inspect  # lazy loading
+    module = _get_real_module(cls)
 
     if (inspect.isgenericalias(cls) and
-            cls.__module__ == 'typing' and cls.__origin__ is Union):
+            module == 'typing' and cls.__origin__ is Union):
         # Union
         if len(cls.__args__) > 1 and cls.__args__[-1] is NoneType:
             if len(cls.__args__) > 2:
@@ -123,10 +170,10 @@ def _restify_py37(cls: Optional["Type"]) -> str:
             return ':obj:`Union`\\ [%s]' % args
     elif inspect.isgenericalias(cls):
         if getattr(cls, '_name', None):
-            if cls.__module__ == 'typing':
+            if module == 'typing':
                 text = ':class:`%s`' % cls._name
             else:
-                text = ':class:`%s.%s`' % (cls.__module__, cls._name)
+                text = ':class:`%s.%s`' % (module, cls._name)
         else:
             text = restify(cls.__origin__)
 
@@ -135,7 +182,7 @@ def _restify_py37(cls: Optional["Type"]) -> str:
         elif all(is_system_TypeVar(a) for a in cls.__args__):
             # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])
             pass
-        elif cls.__module__ == 'typing' and cls._name == 'Callable':
+        elif module == 'typing' and cls._name == 'Callable':
             args = ', '.join(restify(a) for a in cls.__args__[:-1])
             text += r"\ [[%s], %s]" % (args, restify(cls.__args__[-1]))
         elif cls.__args__:
@@ -143,25 +190,25 @@ def _restify_py37(cls: Optional["Type"]) -> str:
 
         return text
     elif hasattr(cls, '__qualname__'):
-        if cls.__module__ == 'typing':
+        if module == 'typing':
             return ':class:`%s`' % cls.__qualname__
         else:
-            return ':class:`%s.%s`' % (cls.__module__, cls.__qualname__)
+            return ':class:`%s.%s`' % (module, cls.__qualname__)
     elif hasattr(cls, '_name'):
         # SpecialForm
-        if cls.__module__ == 'typing':
+        if module == 'typing':
             return ':obj:`%s`' % cls._name
         else:
-            return ':obj:`%s.%s`' % (cls.__module__, cls._name)
+            return ':obj:`%s.%s`' % (module, cls._name)
     elif isinstance(cls, ForwardRef):
         return ':class:`%s`' % cls.__forward_arg__
     else:
         # not a class (ex. TypeVar)
-        return ':obj:`%s.%s`' % (cls.__module__, cls.__name__)
+        return ':obj:`%s.%s`' % (module, cls.__name__)
 
 
 def _restify_py36(cls: Optional["Type"]) -> str:
-    module = getattr(cls, '__module__', None)
+    module = _get_real_module(cls)
     if module == 'typing':
         if getattr(cls, '_name', None):
             qualname = cls._name
@@ -260,25 +307,25 @@ def _restify_py36(cls: Optional["Type"]) -> str:
         else:
             return ':class:`%s`' % qualname
     elif hasattr(cls, '__qualname__'):
-        if cls.__module__ == 'typing':
+        if module == 'typing':
             return ':class:`%s`' % cls.__qualname__
         else:
-            return ':class:`%s.%s`' % (cls.__module__, cls.__qualname__)
+            return ':class:`%s.%s`' % (module, cls.__qualname__)
     elif hasattr(cls, '_name'):
         # SpecialForm
-        if cls.__module__ == 'typing':
+        if module == 'typing':
             return ':obj:`%s`' % cls._name
         else:
-            return ':obj:`%s.%s`' % (cls.__module__, cls._name)
+            return ':obj:`%s.%s`' % (module, cls._name)
     elif hasattr(cls, '__name__'):
         # not a class (ex. TypeVar)
-        return ':obj:`%s.%s`' % (cls.__module__, cls.__name__)
+        return ':obj:`%s.%s`' % (module, cls.__name__)
     else:
         # others (ex. Any)
-        if cls.__module__ == 'typing':
+        if module == 'typing':
             return ':obj:`%s`' % qualname
         else:
-            return ':obj:`%s.%s`' % (cls.__module__, qualname)
+            return ':obj:`%s.%s`' % (module, qualname)
 
 
 def stringify(annotation: Any) -> str:
@@ -301,7 +348,7 @@ def stringify(annotation: Any) -> str:
     elif annotation is NoneType:
         return 'None'
     elif (getattr(annotation, '__module__', None) == 'builtins' and
-          hasattr(annotation, '__qualname__')):
+          hasattr(annotation, '__qualname__') and _is_real_builtin(annotation)):
         return annotation.__qualname__
     elif annotation is Ellipsis:
         return '...'
@@ -314,7 +361,7 @@ def stringify(annotation: Any) -> str:
 
 def _stringify_py37(annotation: Any) -> str:
     """stringify() for py37+."""
-    module = getattr(annotation, '__module__', None)
+    module = _get_real_module(annotation)
     if module == 'typing':
         if getattr(annotation, '_name', None):
             qualname = annotation._name
@@ -366,7 +413,7 @@ def _stringify_py37(annotation: Any) -> str:
 
 def _stringify_py36(annotation: Any) -> str:
     """stringify() for py35 and py36."""
-    module = getattr(annotation, '__module__', None)
+    module = _get_real_module(annotation)
     if module == 'typing':
         if getattr(annotation, '_name', None):
             qualname = annotation._name
